垃圾回收（Garbage collection，简称 GC）是内存管理中一个非常重要的话题，不管是何种编程语言，GC 的目标都是相同的，即准确高效地识别和清理内存中的垃圾对象。

不同编程语言在实现思路上有相似之处，又各自有不同的侧重点，接下来我们对比 Python、Java 和 Go 的 GC 机制来展开聊聊。



# Python的垃圾回收特点

## 引用计数机制为主要策略
Python 通过`ob_refcnt`字段，追踪对象被引用的次数，当计数减至零时，对象生命终结，即刻被垃圾回收机制回收。

这种方式简单明了，即时回收无用对象，避免了程序中长时间占用无用内存的问题，但其自身不能处理循环引用。



## 标记-清除解决循环引用
Python 辅以标记-清除算法，主要处理容器对象的循环引用问题。Python 中的垃圾回收器会周期性地执行，扫描对象，标记所有从根对象集合开始可访问到的对象，未被标记的对象即被认定为垃圾，进行清除。

这种方式确保了即使在复杂关联关系中，内存也能得到有效管理与释放。



## 分代回收优化性能
为了减少引用计数和标记-清除乃至内存整体的管理开销，Python 引入了分代回收机制，该机制将对象分为不同的代（通常是三代），假设对象存活时间越长，越不可能成为垃圾，因此新生代的对象频繁检查回收，老年代对象检查回收频率则低，这样可以大幅减少垃圾回收带来的性能损耗。



# Java的垃圾回收特点

## 可达性分析
Java 垃圾回收器根据从 GC Root 开始的引用链，判定对象是否可达。

所谓 GC Root，包括类静态属性、活动线程、JNI 引用等。若对象在引用链上，则视为可达；反之，视为垃圾。这种分析方法摒弃了引用计数的局限，有效避免了循环引用问题。



## 分代回收机制
Java 内存空间被划分为年轻代、老年代和永久代（后改进为元空间），这样的分代机制让 Java 的垃圾回收更高效。

年轻代适用更快的垃圾回收算法，因为年轻代对象生命周期短，死亡速度快。对于老年代，由于其包含生命周期长的对象，因此使用不同的回收策略，减少回收频率，节约系统资源。



## 多种垃圾回收器选择
Java 提供了多种垃圾回收器，比如 Serial、Parallel、CMS、G1 及 ZGC 等，应对不同的使用场景。

比如，Serial 适合客户端模式，而 G1 垃圾回收器更适合需要大内存、多核服务器环境使用，实现了高并发和低停顿时间，它们各取所长，为开发者提供了丰富的内存管理选项。



# Go的垃圾回收特点

## 三色标记法
Go 语言自 v1.5 以来，采用了三色标记法，在程序运行期间进行垃圾回收，程序执行并未完全中断，这一并发垃圾回收机制提高了回收效率。

在操作中，对象在初始被视为白色（可能是垃圾），然后可达对象在遍历过程中变为灰色（待处理）和最终的黑色（存活对象），未标记到的对象即为垃圾，准备被回收。



## 三色不变性

在垃圾收集领域，三色不变性是并发标记算法中的一个重要概念。想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：

- 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
- 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径；

它确保了在整个标记过程中，不会错误地回收还在使用的对象。



## 混合写屏障
混合写屏障正是基于三色不变式的一种优化实践，它在 Go 的垃圾收集器中负责在并发标记阶段维护三色不变式的正确性。在 Go v1.8 中引入后，混合写屏障结合了“插入”和“删除”屏障的策略，巧妙地减少了因为程序的运行而带来的标记干扰。

插入屏障是指在对象引用时进行干预，而删除屏障则是在对象引用被删除时进行操作。通过这一策略，Go 确保了在对象图的动态变化下，也不会因为遗漏对新活对象的标记或错误地标记死对象而破坏垃圾收集的准确性，这是并发收集算法中的一个巨大突破。

