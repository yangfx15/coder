大家好，我是小❤。

作为一名在分布式领域混迹多年的资深老油子兼后台开发攻城狮，小❤深知：分布式系统中，**确保数据一致性和协调多个节点之间的并发操作是一项重要而复杂的任务**。

![image-20231009233920257](imgs/image-20231009233920257.png)

在这篇文章中，我将带大家深入了解分布式系统中的同步利器——分布式锁，是如何解决分布式系统中的并发问题的。



## 什么是分布式锁？

在分布式系统中，分布式锁是一种机制，用于协调多个节点上的并发访问共享资源。

这个共享资源可以是数据库、文件、缓存或任何需要互斥访问的数据或资源。**分布式锁确保了在任何给定时刻只有一个节点能够对资源进行操作，从而保持了数据的一致性和可靠性。**



## 为什么要使用分布式锁？

### 1. 数据一致性

在分布式环境中，多个节点同时访问共享资源可能导致数据不一致的问题。分布式锁可以防止这种情况发生，确保数据的一致性。



### 2. 防止竞争条件

多个节点并发访问共享资源时可能出现竞争条件，这会导致不可预测的结果。分布式锁可以有效地防止竞争条件，**确保操作按照预期顺序执行**。



### 3. 限制资源的访问

有些资源可能需要限制同时访问的数量，以避免过载或资源浪费。分布式锁可以帮助**控制资源的访问**。



## 分布式锁要解决的问题

分布式锁的核心问题是如何在多个节点之间协调，以确保只有一个节点可以获得锁，而其他节点必须等待。

![img](imgs/lock.jpg)

这涉及到以下关键问题：

### 1. 互斥性

只有一个节点能够获得锁，其他节点必须等待。这确保了资源的互斥访问。



### 2. 可重入性

允许同一个节点多次获得锁，以避免死锁情况。



### 3. 死锁避免

确保即使节点在获取锁时发生故障，锁也会被释放，避免死锁。



## 分布式锁的实现方式

在分布式系统中，有多种方式可以实现分布式锁，每种方式都有其优点和缺点，以下是一些常见的分布式锁实现方式。



### 1. 基于数据库的分布式锁

使用数据库表中的一行记录作为锁，通过事务来获取和释放锁。

例如，使用 `MySQL` 来实现事务锁。首先创建一张简单表，在某一个字段上创建唯一索引（保证多个请求新增字段时，只有一个请求可成功）。

``` sql
CREATE TABLE `user` (   
    `id` bigint(20) NOT NULL AUTO_INCREMENT,   
    `uname` varchar(255) DEFAULT NULL,   
    PRIMARY KEY (`id`),   
    UNIQUE KEY `name` (`uname`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4
```

当需要获取分布式锁时，执行以下语句：

``` sql
INSERT INTO `user` (uname) VALUES ('methodName')
```

由于 `name` 字段上加了唯一索引，所以当多个请求提交 `insert` 语句时，只有一个请求可成功。

使用 `MySQL` 实现分布式锁的优点是可靠性高，但性能较差。而且这把锁是**非重入的，同一个线程在没有释放锁之前无法获得该锁**。



### 2. 基于ZooKeeper的分布式锁

**Zookeeper（简称 zk）是一个为分布式应用提供一致性服务的中间组件**，其内部是一个分层的文件系统目录树结构。

zk 规定其某一个目录下只能有唯一的一个文件名，其分布式锁的实现方式如下：

1. **创建一个锁目录（ZNode）**：首先，在 zk 中创建一个专门用于存储锁的目录，通常称为锁根节点。这个目录将包含所有获取锁的请求以及用于锁协调的节点。
2. **获取锁**：当一个节点想要获取锁时，它会在锁目录下创建一个临时顺序节点（Ephemeral Sequential Node）。zk 会为每个节点分配一个唯一的序列号，并根据序列号的大小来确定锁的获取顺序。
3. **查看是否获得锁**：节点在创建临时顺序节点后，需要检查自己的节点是否是锁目录中序列号最小的节点。如果是，表示节点获得了锁；如果不是，则节点需要监听比它序列号小的节点的删除事件。
4. **监听锁释放**：如果一个节点没有获得锁，它会设置一个监听器来监视比它序列号小的节点的删除事件。一旦前一个节点（序列号小的节点）释放了锁，zk 会通知等待的节点。
5. **释放锁**：当一个节点完成了对共享资源的操作后，它会删除自己创建的临时节点，这将触发 zk 通知等待的节点。

zk 分布式锁提供了良好的一致性和可用性，但部署和维护较为复杂，需要仔细处理各种边界情况，例如节点的创建、删除、网络分区等。

而且 zk 实现分布式锁的性能不太好，主要是获取和释放锁都需要在集群的 `Leader` 节点上执行，同步较慢。



### 3. 基于缓存的分布式锁

使用分布式缓存，如 Redis 或 Memcached，来存储锁信息，缓存方式性能较高，但需要处理分布式缓存的高可用性和一致性。

接下来，我们详细讨论一下在 Redis 中如何设计一个高可用的分布式锁以及可能会遇到的几个问题，包括：

1. 死锁问题
2. 锁提前释放
3. 锁被其它线程误删
4. 高可用问题



#### 1）死锁问题

早期版本的 `redis` 没有 `setnx` 命令在写 key 时直接设置超时参数，需要用 `expire` 命令单独对锁设置过期时间，会导致死锁问题。

比如，设置锁的过期时间执行失败了，导致后来的抢锁都会失败。



#### Lua脚本或SETNX

为了保证原子性，我们可以使用 Lua 脚本，保证`SETNX + EXPIRE`两条指令的原子性，我们还可以巧用`Redis` 的 `SET` 指令扩展参数：`SET key value[EX seconds][PX milliseconds][NX|XX]`，它也是原子性的。

> SET key value \[EX seconds] \[PX milliseconds] [NX|XX]
>
> - NX：表示 `key` 不存在的时候，才能 `set` 成功，即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等待锁释放后，才能获取。
> - EX seconds :设定 `key` 的过期时间，默认时间单位为秒。
> - PX milliseconds: 设定 `key` 的过期时间，默认单位为毫秒
> - XX: 仅当 `key` 存在时设置值



在 Go 语言里面，关键代码如下所示：

``` go
func getLock() {     
    methodName := "getLock"     
    val, err := client.Do("set", methodName, "lock_value", "nx", "ex", 100) 	
    if err != nil {         
        zaplog.Errorf("%s redis error, %s", methodName, err)
        return
    }     
    if val == nil { 		
        zaplog.Errorf("%s get redis lock error", methodName)         
        return 	
    }
    ... // 执行临界区代码，访问公共资源
    client.Del(lock.key()).Err()
}
```



#### 2）锁提前释放

上述方案解决了加锁过期的原子性问题，不会产生死锁，但还是可能存在锁提前释放的问题。

如图所示，假设我们设置锁的过期时间为 5 秒，而业务执行需要 10 秒。

![image-20231009214651354](imgs/image-20231009214651354.png)

在线程 1 执行业务的过程中，它的锁被过期释放了，这时线程 2 是可以拿到锁的，也开始访问公共资源。

很明显，这种情况下导致了**公共资源没有被严格串行访问，破坏了分布式锁的互斥性**。

这时，有爱动脑瓜子的小伙伴可能认为，既然加锁时间太短，那我们把锁的过期时间设置得长一些不就可以了？

其实不然，首先我们没法提前准确知道一个业务执行的具体时间。其次，公共资源的访问时间大概率是动态变化的，时间设置得过长也不好。



#### Redisson框架

所以，我们不妨给加锁线程一个自动续期的功能，即**每隔一段时间检查锁是否还存在，如果存在就延长锁的时间，防止锁过期提前释放**。

这个功能需要用到守护线程，当前已经有开源框架帮我们解决了，它就是——Redisson，它的实现原理如图所示：

![image-20231009220136100](imgs/image-20231009220136100.png)

当线程 1 加锁成功后，就会启动一个 `Watch dog` 看门狗，它是一个后台线程，每隔 1 秒（可配置）检查业务是否还持有锁，以达到线程未主动释放锁，自动续期的效果。



#### 3）锁被其它线程误删

除了锁提前释放，我们可能还会遇到锁被其它线程误删的问题。

![image-20231009221736642](imgs/image-20231009221736642.png)

如图所示，加锁线程 1 执行完业务后，去释放锁。但线程 1 自己的锁已经释放了，此时分布式锁是由线程 2 持有的，就会误删线程 2 的锁，但线程 2 的业务可能还没执行完毕，导致异常产生。 



#### 唯一 Value 值

要想解决锁被误删的问题，我们需要给每个线程的锁加一个唯一标识。

比如，在加锁时将 `Value` 设置为线程对应服务器的 IP。对应的 Go 语言关键代码如下：

``` go
const (   
    // HostIP，当前服务器的IP   
    HostIP = getLocalIP()
)

func getLock() {     
    methodName := "getLock"     
    val, err := client.Do("set", methodName, HostIP, "nx", "ex", 100) 	
    if err != nil {         
        zaplog.Errorf("%s redis error, %s", methodName, err)
        return
    }     
    if val == nil { 		
        zaplog.Errorf("%s get redis lock error", methodName)         
        return 	
    }
    ... // 执行临界区代码，访问公共资源
    if client.Get(methodName) == HostIP {
        client.Del(lock.key()).Err()
    }
}
```

这样，在删除锁的时候判断一下 `Value` 是否为当前实例的 IP，就可以避免误删除其它线程锁的问题了。

为了保证严格的原子性，可以用 `Lua` 脚本代替以上代码，如下所示：

``` lua
if redis.call('get',KEYS[1]) == ARGV[1] then 
   return redis.call('del',KEYS[1]) 
else
   return 0
end;
```



#### 4）Redlock高可用锁

前面几种方案都是基于单机版考虑，而实际业务中 Redis 一般都是集群部署的，所以我们接下来讨论一下 Redis 分布式锁的高可用问题。

试想一下，如果线程 1 在 Redis 的 `master` 主节点上拿到了锁，但是还没同步到 `slave` 从节点。

这时，如果主节点发生故障，从节点升级为主节点，其它线程就可以重新获取这个锁，**此时可能有多个线程拿到同一个锁。即，分布式锁的互斥性遭到了破坏。**

为了解决这个问题，Redis 的作者提出了专门支持分布式锁的算法：Redis Distributed Lock，简称 Redlock，其核心思想类似于注册中心的*选举机制*。

![image-20231009225854111](imgs/image-20231009225854111.png)

Redis 集群内部署多个 `master` 主节点，它们相互独立，即每个主节点之间不存在数据同步。

且节点数为单数个，每次当客户端抢锁时，需要从这几个 `master` 节点去申请锁，当从一半以上的节点上获取成功时，锁才算获取成功。



## 优缺点和常用实现方式

以上是业界常用的三种分布式锁实现方式，它们各自的优缺点如下：

- **基于数据库的分布式锁**：可靠性高，但性能较差，不适合高并发场景。
- **基于ZooKeeper的分布式锁**：提供良好的一致性和可用性，适合复杂的分布式场景，但部署和维护复杂，且性能不如缓存的方式。
- **基于缓存的分布式锁**：性能较高，适合大部分场景，但需要处理缓存的高可用性。



## 小结

综上，我们介绍了互联网应用常见的几种分布式锁的解决方案。其中，业界常用的分布式锁实现方式通常是基于缓存的方式，如`使用 Redis 实现分布式锁`。这是因为 Redis 性能优秀，而且可以满足大多数应用场景的需求。

分布式锁是分布式系统中的一项关键技术，它为我们解决了在多节点环境下的同步问题提供了有效的方法。

所以，无论你的应用规模如何，了解分布式锁的工作原理和各种实现方式都是非常有价值的。

最后，希望这篇文章能够帮助大家更深入地理解分布式锁的重要性和实际应用。

如果大家觉得有所收获或者启发，不妨关注、点赞我，或者把文章分享给更多人吧！这会让我有充足的动力，持续输出大家喜爱的技术内容哦~

我是小❤，我们下期再见！