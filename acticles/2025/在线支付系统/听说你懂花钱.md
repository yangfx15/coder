### 引言

大家好，我是技术圈最懂 “花钱” 的小 ❤～

你有没有过这样的经历？双 11 凌晨蹲点付款，点击 “确认支付” 后屏幕转圈半天没反应，手心直冒冷汗怕错过优惠；或者春节发红包，刚点出去就提示 “支付失败”，群里亲友催着 “补一个” 的消息不断弹出 —— 那一刻，是不是特别想知道：**明明平时付款秒到，为啥关键时刻支付系统会 “掉链子”**？

如今我们出门不带现金，买奶茶、打车、缴水电费全靠手机支付，支付宝、微信支付每天要处理数十亿笔交易，**峰值时每秒甚至能扛住上百万次请求**。

这背后的在线支付系统，可不是简单的 “扣钱 + 打款”，而是一套能抗住**高并发、保障资金安全、实现跨平台互通**的复杂技术体系。

今天就带大家扒一扒在线支付系统的 “家底”：从整体架构到核心功能，从关键技术到踩过的坑，看完这篇，你不仅能懂支付系统的运作逻辑，下次再遇到支付问题，还能跟朋友唠唠 “这大概率是某个环节的容灾没做好”～



### 1. 整体架构

在线支付系统就像一个 “数字银行柜台”，既要对接用户（`客户端`）、商家（`商户系统`），还要联动`银行、第三方支付机构（如银联）`，同时得 `防黑客、堵漏洞`，确保每一笔钱都 “来去分明”。它的核心是 “**分层解耦 + 分布式架构**”，哪怕某一个模块出问题，也不会影响整体支付流程。

架构图：

![image-20250903033512182](imgs/image-20250903033512182.png)

涉及前后端关键组件如下：

> **客户端**：用户操作入口，包括 APP（支付宝 / 微信支付）、H5 页面（商家付款页）、小程序，核心是渲染支付界面、调用支付 SDK（如微信 JSSDK）、接收支付结果通知。

**API 网关**：支付系统的 “交通枢纽”，负责请求路由（比如把微信支付请求转发到微信通道，支付宝请求转发到支付宝通道）、鉴权（验证商户 API 密钥、用户 Token）、限流（防止某商户恶意刷请求，比如每秒最多 100 笔）、日志记录（每笔请求都要留痕，方便后续对账）。

**支付核心服务**：系统的 “大脑”，拆解为 3 个子服务：

- 订单服务：生成支付订单（唯一订单号），关联用户、商户、金额、商品信息；

- 通道服务：对接不同支付通道（微信、支付宝、银联、银行网银），封装统一的支付接口（商户不用关心对接微信还是支付宝，调用一个接口即可）；

- 结果服务：接收支付通道的异步回调（比如微信支付成功后会通知系统），更新订单状态。

**账户服务**：管理用户 / 商户的资金账户，包括余额查询、充值、提现、冻结（比如退款时冻结对应金额），是资金安全的核心模块。

**对账服务**：每天和支付通道、银行对账，核对交易金额、笔数是否一致，解决 “多扣钱”“漏打款” 问题，是支付系统的 “财务审计员”。



涉及基础组件包括：

> **分布式数据库**：用 MySQL 分库分表（按订单号哈希分片）存储订单、账户数据，搭配 TiDB 应对海量数据的高并发读写；

**消息队列（Kafka/RocketMQ）**：解耦服务间依赖，比如支付成功后发送 “订单完成” 消息，让物流、积分系统异步处理，避免支付流程卡顿；

**分布式缓存（Redis 集群）**：缓存热门商户的支付配置、用户余额（减少 DB 查询）、防重复提交令牌（比如防止用户重复点击支付）；

**分布式锁（Redis/ZooKeeper）**：解决并发下的资金安全问题，比如同一用户同时发起两笔支付，确保余额只扣一次。

主要功能包括：支付发起、支付结果回调、交易对账、退款处理，下面我们逐个拆解这些核心流程～



### 2. 支付发起：从 “点击付款” 到 “等待支付”

你在奶茶店扫码付款时，看似简单的 “扫码→输密码→支付成功”，背后其实经历了 6 个关键步骤。这一步的核心是 “确保订单不重复、金额不篡改、通道能兼容”。

业务流程图如下：

![image-20250903024328223](imgs/image-20250903024328223.png)

具体流程拆解：

1. **用户触发支付**：你在商家 H5 页面点击 “微信支付”，客户端携带 “商品 ID、金额（15 元）、商户 ID” 请求 API 网关；

1. **网关鉴权与路由**：网关验证商户 API 密钥是否有效（防止伪造请求），判断请求频率是否超限（比如该商户每秒最多 10 笔），然后转发到支付核心的 “订单服务”；

1. **生成支付订单**：订单服务生成唯一订单号（比如 P20250902123456789），校验金额是否合法（比如不能为 0 或负数），关联商户的支付通道配置（该商户已开通微信支付，配置了微信商户号），将订单数据写入 MySQL 分表；

1. **请求支付通道**：订单服务调用 “通道服务”，通道服务根据 “微信支付” 类型，封装微信支付需要的参数（如 appid、mch_id、nonce_str、签名），调用微信支付的 “统一下单接口”；

1. **获取支付凭证**：微信支付接口返回 “prepay_id”（预支付 ID），通道服务将其封装成客户端能识别的格式（比如微信 APP 支付需要的 sign、timestamp），通过网关返回给客户端；

1. **客户端唤起支付**：客户端拿到凭证后，调用微信支付 SDK，唤起微信 APP 的支付界面，你输入密码或验证指纹后，微信开始处理支付。

这里有两个关键技术点：

- **防重复提交**：订单服务生成订单时，会向 Redis 写入 “用户 ID + 商品 ID” 的令牌，有效期 5 分钟，若同一用户 5 分钟内重复发起同一商品的支付，直接返回已存在的订单，避免生成多笔订单；

- **签名验证**：通道服务调用支付通道时，会用商户的 API 密钥对参数签名，支付通道（如微信）收到请求后会重新计算签名，若不一致则拒绝，防止参数被黑客篡改（比如把 15 元改成 1.5 元）。



### 3. 支付结果回调：从 “支付成功” 到 “订单完成”

你输完密码后，手机弹出 “支付成功” 提示，这时商家的收银系统也会同步收到通知 —— 这一步靠的是 “支付通道异步回调”，核心是 “确保结果不丢失、状态不混乱”。

业务时序图如下：

![image-20250903031150797](imgs/image-20250903031150797.png)

具体流程拆解：

1. **支付通道触发回调**：微信支付完成扣款后，会向我们系统配置的 “回调地址”（比如[https://pay.xx](https://pay.xxx.com/callback/wechat)[x.com](https://pay.xxx.com/callback/wechat)[/call](https://pay.xxx.com/callback/wechat)[back/](https://pay.xxx.com/callback/wechat)[wecha](https://pay.xxx.com/callback/wechat)[t](https://pay.xxx.com/callback/wechat)）发起 POST 请求，携带支付结果（订单号、支付金额、交易状态 SUCCESS）；

1. **回调接口验签**：通道服务的回调接口先验证微信的签名（防止伪造回调，比如黑客伪造 “支付成功” 消息骗商家发货），校验通过后解析回调参数；

1. **更新订单状态**：通道服务调用 “结果服务”，结果服务用分布式锁锁住该订单号（防止同一订单的两次回调同时处理），查询订单当前状态（此时为 “待支付”），将其更新为 “支付成功”，同时记录交易流水号（微信返回的 transaction_id）；

1. **异步通知关联系统**：结果服务向 Kafka 发送 “支付成功” 消息，消息包含订单号、用户 ID、金额，积分系统消费消息给用户加 15 积分，物流系统消费消息触发 “打包发货”（若为电商订单）；

1. **通知客户端结果**：结果服务通过 WebSocket 或推送（如极光推送）向用户客户端发送 “支付成功” 通知，同时调用商户的 “回调接口”，告知商户该订单已支付；

1. **日志与监控**：整个过程记录详细日志（包括回调参数、处理结果），同时上报监控指标（如 “支付成功数”“回调处理耗时”），若回调失败（比如商户接口超时），会触发重试机制（每隔 10 分钟重试一次，共重试 3 次）。

这里最容易踩的坑是 “回调重复处理”：比如微信支付因网络波动，同一笔支付发起了两次回调，这时分布式锁就起了作用 —— 第一个回调拿到锁后更新订单状态，第二个回调拿锁失败，查询订单已为 “支付成功”，直接返回成功，避免重复扣减商户余额。



### 4. 交易对账：每天凌晨的 “财务审计”

你可能没注意到，每天凌晨 2-4 点，支付系统会自动和微信、支付宝、银行对账 —— 这一步是 “资金安全的最后防线”，确保我们系统的交易数据和通道方一致，没有 “多扣用户钱” 或 “少收商家钱”。

对账交互图如下：

![image-20250903034214789](imgs/image-20250903034214789.png)

具体步骤：

1. **获取通道对账文件**：凌晨 2 点，对账服务自动从微信支付、支付宝的后台下载 “对账文件”（CSV 格式，包含当天每笔交易的订单号、金额、手续费、交易时间）；

1. **生成系统对账文件**：对账服务从 MySQL 分表、TiDB 中读取当天的所有支付订单，按相同格式生成 “系统对账文件”；

1. **字段匹配对账**：对账服务按 “订单号” 或 “交易流水号” 关联两个文件，对比关键字段：

- - 金额一致、交易状态一致（系统显示成功，通道也显示成功）：标记为 “对账成功”；

- - 系统有订单，通道没有：标记为 “单边账（系统多）”，可能是通道回调没收到，需要人工核实；

- - 通道有交易，系统没有：标记为 “单边账（通道多）”，可能是系统回调处理失败，需要补录订单；

- - 金额不一致：标记为 “金额差异”，比如系统显示 15 元，通道显示 14.9 元，可能是手续费计算错误，需要查日志；

1. **异常处理与归档**：对账服务将异常订单推送到 “对账异常平台”，通知运维和财务人员处理；处理完成后，将对账结果归档到 HDFS（海量存储），保留至少 3 年（符合金融监管要求）；

1. **生成对账报告**：对账服务生成当天的对账报告（总交易笔数、总金额、异常笔数、异常率），发送给运营和财务团队。

这里的技术难点是 “海量数据对账效率”：比如某天有 1 亿笔交易，对账文件有几十 GB，直接加载到内存会 OOM。我们的解决方案是 “分块对账 + Spark 分布式计算”：将对账文件按订单号哈希分成 100 个块，用 Spark 集群并行处理，原本需要 2 小时的对账，现在 30 分钟就能完成。



### 6. 一些难点和要点：支付系统的 “避坑指南”

做支付系统就像走钢丝，既要扛住高并发，又要保证资金安全，这些年我们踩过不少坑，也总结了一些解决方案，分享给大家～

#### 1）高并发下的 “余额超扣” 问题

**场景**：某电商大促时，同一用户同时发起两笔支付（比如抢两件商品），用户余额只有 100 元，两笔订单各 50 元，理论上刚好够，但并发下可能扣成 “-50 元”（超扣）。

**原因**：传统的 “查询余额→判断是否足够→扣减余额” 是串行操作，并发时会出现 “脏读”—— 第一个请求查询余额 100 元，还没扣减，第二个请求也查到 100 元，两个请求都判断 “足够”，最后扣成 50-50=0？不，实际会扣成 100-50-50=0？不对，若两个请求同时执行扣减，会变成 100-50=50（第一个），100-50=50（第二个），最终余额 50 元，多扣了 0 元？不，正确的问题是 “两个请求同时读余额 100，都扣 50，最终余额 0，但实际应该扣两次 50，余额 0，没问题？”—— 哦，更常见的是 “用户余额 99 元，两笔订单各 50 元，并发下都判断 99≥50，最终扣成 99-50-50=-1 元”。

**解决方案**：

- 用 “数据库行锁”：扣减余额时执行UPDATE account SET balance = balance - 50 WHERE user_id = 123 AND balance >= 50，利用 MySQL 的行锁确保同一用户的扣减操作串行执行，且只有余额足够时才扣减；

- 加 “分布式锁”：扣减前用 Redis 的 SETNX 命令获取 “user_123_balance_lock” 锁，获取成功才执行扣减，执行完释放锁，防止并发操作。

通过这两个方案，我们把 “余额超扣” 的概率降到了 0.001% 以下，剩下的通过对账补正。



#### 2）支付通道 “降级与容灾”：避免某通道挂了影响支付

**场景**：微信支付某天凌晨升级，接口暂时不可用，若所有用户都只能用微信支付，会导致支付失败，影响商家生意。

**原因**：支付系统过度依赖单一通道，没有备用方案，通道故障直接导致服务不可用。

**解决方案**：

- **通道降级策略**：在通道服务中配置 “降级开关”，当微信支付接口失败率超过 5%（通过监控发现），自动将该商户的微信支付通道降级为 “支付宝支付”，客户端只显示支付宝选项；

- **多通道容灾**：核心商户开通至少 2 个支付通道（如微信 + 支付宝），通道服务根据 “通道健康度”（成功率、响应时间）动态选择最优通道，比如微信响应慢时，自动路由到支付宝；

- **本地缓存通道配置**：将商户的通道配置缓存到 Redis，即使通道服务挂了，订单服务也能从缓存中获取通道信息，发起支付请求。

去年双 11 期间，某支付通道临时故障，我们的降级策略在 10 秒内生效，将 98% 的请求路由到备用通道，支付成功率仅下降 0.2%，几乎没影响用户体验。



#### 3）防刷单与防欺诈：守住资金安全的 “大门”

**场景**：有黑客利用 “伪造商户”“重复退款”“盗刷他人账户” 等方式套取资金，比如伪造一个商户，生成虚假订单，用盗刷的银行卡支付，再申请退款到自己的账户。

**原因**：支付系统缺乏有效的风控机制，对异常交易识别不及时。

**解决方案**：

- **商户风控**：商户入驻时严格审核资质（营业执照、法人身份证、对公账户），开通支付通道前进行 “商户实名认证”，防止伪造商户；