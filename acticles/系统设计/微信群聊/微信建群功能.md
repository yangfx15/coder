## 1. 引言

大家好，我是小❤。

当我那天拿着手机，正在和朋友们的微信群里畅聊着八卦新闻和即将到来的周末计划时，忽然一个疑问萦绕心头：微信的这个群聊系统是如何设计的，让我们可以方便地聊天、分享图片和表情，还有那个神奇的红包功能？

这个问题一直困扰着，于是我决定深入了解一下，看看微信的群聊系统背后的设计是怎样的。

微信作为 10 亿用户级别的全民 App，想必大家都用过，微信建群功能是微信里面核心的一个能力，它可以将数百个好友或陌生人放进一个群空间。

或许你已经在微信上体验过很多次群组聊天，但你是否好奇过这个背后的系统是如何设计的呢？

今天我们就来探讨一下。



微信建群功能的背后是一套精心设计的架构，它确保了高并发、高性能，以及海量用户数据的存储和管理。

今天，小❤会结合微信群聊的核心功能，一步一步地介绍它的系统设计。



## 2. 系统需求

### 2.1 系统特点与功能需求

微信群聊功能是社交应用的核心功能之一，它允许用户创建自己的社交圈子，与家人、朋友或共同兴趣爱好者进行友好地交流。

当然了，不包括打工人的公司群聊，因为那个群大多数朋友（包括我自己），根本不想看到任何消息，除了抢红包。

以下是微信群聊系统的核心功能：

![image-20231017205423808](imgs/image-20231017205423808.png)

- **创建群聊**：用户可以创建新的聊天群组，邀请其他好友用户加入或与陌生人面对面建群。
- **群组管理**：群主和管理员能够管理群成员，设置规则和权限。
- **消息发送和接收**：允许群成员发送文本、图片、音频、视频等多种类型的消息，并推送给所有群成员。
- **实时通信**：消息应该能够快速传递，确保实时互动。
- **抢红包**：用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包。



### 2.2 非功能需求：应对高并发、高性能、海量存储

当我们面对10亿微信用户每天都可能使用建群功能的情景时，就需要处理大规模的用户并发。这就引出了系统的非功能需求，包括：

- **高并发**：系统需要支持大量用户同时创建和使用群组，以确保无延迟的用户体验。
- **高性能**：快速消息传递、即时响应，是数字社交的关键。
- **海量存储**：系统必须可扩展，以容纳用户生成的海量消息文本、图片及音视频数据。



## 3. 概要设计

在概要设计中，我们考虑了系统的核心组件和基本业务的概要设计。

### 3.1 核心组件

微信群聊系统中，会涉及到如下核心组件或协议。

![image-20231020090525609](imgs/image-20231020090525609.png)

* **客户端**：接收手机或 PC 端微信群聊的消息，并实时传输给后台服务器
* **Websocket传输协议**：支持客户端和后台服务端的实时交互，开销低，实时性高，常用于微信、QQ 等 IM 系统通信系统
* **长连接集群**：与客户端进行 Websocket 长连接的系统集群，并将消息通过中间件转发到应用服务器
* **消息处理服务器**：提供实时消息的处理能力，包括数据存储、查询、与数据库交互等

- **消息推送服务器**：这是信息的中转站，负责将消息传递给正确的群组成员
- **数据库服务器**：用于存储用户文本数据、图片的缩略图、音视频元数据等
- **分布式文件存储**：存储用户图片、音视频等文件数据



### 3.2 业务概要设计

#### 创建群聊

- **唯一ID分配**：当用户请求创建一个新群组时，系统生成一个唯一的群组 ID，通常可以使用分布式 ID 生成器如雪花算法（Snowflake）。
- **群组信息存储**：将群组 ID 和相关信息（例如群名、创建者 ID 等）存储在群组数据库中。
- **成员关联**：将群主添加为群组的创始成员，同时创建者也会成为管理员。
- **消息历史记录**：为了确保新成员能够访问以前的消息，将此新群组的群组 ID 与用户消息关联存储。

除了拉好友建群，微信还实现了面对面建群的能力。

接下来，我们深入探讨了三到四个核心功能的详细设计，包括面对面建群、消息发送与接收及抢红包功能。



## 4. 面对面建群

用户发起面对面建群，并输入一个 4 位数的随机码，周围的用户输入该随机码后可加入群聊。

面对面建群功能通常涉及数据表设计和核心业务交互流程如下。

### 4.1 数据库表设计

1. **User 表**：存储用户信息，包括用户ID、昵称、头像等。
2. **Group 表**：存储群组信息，包括群ID、群名称、创建者ID等。
3. **GroupMember 表**：关联用户和群组，包括用户ID和群ID。
4. **RandomCode 表**：存储面对面建群的随机码和关联的群ID。



### 4.2 核心业务交互流程

![image-20231020093539062](imgs/image-20231020093539062.png)

用户 A 在手机端应用中发起面对面建群，并输入一个随机码，校验通过后，等待周围（50 米之内）的用户加入。此时，系统将用户信息以 HashMap 的方式存入缓存中。

``` json
{随机码，用户列表[用户A(ID、名称、头像)]}
```

用户 B 在另一个手机端发起面对面建群，输入指定的随机码，如果该用户周围有这样的随机码，则进入同一个群聊等待页面，并可以看到其它群员的头像和昵称信息。

此时，系统除了根据随机码获取所有用户信息，也会实时更新缓存里的用户信息。

![image-20231026223956822](imgs/image-20231026223956822.png)

当第一个用户点击**进入该群**时，就可以加入群聊，系统将生成的随机码保存在 RandomCode 表中，并关联到新创建的群 ID。

然后，系统将用户信息和新生成的群聊信息存储在 Group、GroupMember 表中



之后 B、C 用户带着随机码加入群聊时，手机客户端向服务器后端发送请求，验证随机码是否有效。服务器后端验证随机码，检查随机码是否存在于 RandomCode 表中，以及是否在有效期内。



如果验证通过，服务器后端将用户 B、C 添加到群成员表GroupMember中，并返回成功响应。

移动客户端应用收到成功响应后，更新用户 B、C 的群聊列表，展示他们已加入的新群聊。



这样，用户A通过创建随机码和周围的用户扫描二维码的方式成功建立了一个面对面建群。这个功能涉及了多个技术组件，包括服务器后端、数据库、二维码生成和验证等。同时，用户A作为群的创建者，在数据库中也会被标记为群主，有权限管理群成员。



## 5. 消息发送与接收

当某个成员在微信群里发言，系统需要处理消息的分发、通知其他成员、以及确保消息的显示。以下是这一功能的详细交互步骤，相关技术组件和数据库表存储方案。



### 5.1 交互流程

消息发送和接收时序图如下：

![image-20231026094116788](imgs/image-20231026094116788.png)

1. 用户A在群中发送一条带有图片、视频或音频的消息。
2. 移动客户端应用将消息内容和媒体文件上传到服务器后端。
3. 服务器后端接收到消息和媒体文件后，将消息内容存储到 Message 表中，同时将媒体文件存储到分布式文件存储集群中。在 Message 表里，不仅会记录媒体文件的 MediaID，以便关联消息和媒体；还记录了缩略图、视频封面图等等。
4. 服务器后端会向所有群成员广播这条消息。移动客户端应用接收到消息后，会根据消息类型（文本、图片、视频、音频）加载对应的展示方式。
5. 当用户点击查看图片、视频或音频缩略图时，客户端应用会根据 MediaID 到对象存储集群中获取对应的媒体文件路径，并将其展示给用户。

这个流程确保了消息和媒体文件的有效存储和展示。用户可以上传和查看各种类型的媒体数据，而服务器后端通过关联 Message 和对象存储服务器中的信息，实现了有效的消息存储和展示。



### 5.2 消息存储和展示

在微信群中保存和展示用户的图片、视频或音频数据，通常需要进行数据存储和展示方面的设计。除了上面提到的用户表和群组表以外，还需要以下表结构：

1. **Message表：** 用于存储消息，每个消息都有一个唯一的 MessageID，消息类型（文本、图片、视频、音频），消息内容（文字、图片缩略图、视频封面图等），发送者 UserID、接收群 GroupID、发送时间等字段。
4. **Media表：** 存储用户上传的图片、视频、音频等媒体数据。每个媒体文件都有一个唯一的 MediaID，文件路径、上传者 UserID、上传时间等字段。
3. **MessageState表：** 用于存储用户消息状态，包括 MessageID、用户 ID、是否已读等。在消息推送时，通过这张表计算未读数，统一推送给用户，并在离线用户的手机上展示一个小数字代表消息未读数。

为了服务的查询性能考虑，也可以考虑将用户的已读状态存入 Redis，并实时记录一个未读数值。并且，当未读数大于 99 时，就将未读数值置为 100 且不再增加。

当推送用户消息时，只要未读数为 100，就将推送消息数设置为 99+，以此来提升存储的性能和交互的效率。



## 6. 抢红包

思路：https://zhuanlan.zhihu.com/p/537702244

Redis详细方案（时序图）：https://juejin.cn/post/6925947709517987848

算法解密：http://www.52im.net/thread-3125-1-1.html



抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要保证每个用户的红包金额不小于 0.01 元。

抢红包的详细交互流程如下：

1. 用户接收到抢红包通知，点击通知打开群聊页面
2. 用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包
4. 若用户资格验证通过，后台服务分配红包金额并存储领取记录
5. 用户在微信群中看到领取金额，红包状态更新为“已领取”
5. 异步调用支付接口，将红包金额更新到钱包里

需要关注抢红包的数据库设计，抢红包实时性和红包分配算法。



### 数据库设计

红包表 `redpack` 的字段如下：

* **id：** 主键，红包ID
* **totalAmount：** 总金额
* **surplusAmount：** 剩余金额
* **total：** 红包总数
* **surplusTotal：** 剩余红包总数
* **userId：** 发红包的用户ID
* **version：** 版本号

该表用来记录用户发了多少红包，以及需要维护的剩余金额。



红包记录表 `redpack_record` 如下：

* **id：** 主键，记录ID
* **redpackId：** 红包ID，外键
* **userId：** 用户ID
* **amount：** 抢到的金额

记录表用来存放用户具体抢到的红包信息，也是红包表的副表。



### 实时性

#### 发红包

1. 用户设置红包的总金额和个数后，开始发红包
2. 分配好在红包表中增加一条数据，版本号为初始版本号
3. 为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，存储红包 ID 和总人数 n



#### 抢红包

从 2015 年后，微信红包的抢红包和拆红包就分离了，用户点击抢红包后需要进行两次操作。这也是为什么明明有时候抢到了红包，点开后却发现**该红包已经被领取完了**，具体步骤如下。

1. 抢红包：抢操作在 Redis 缓存层完成，通过原子递减的操作来更新红包个数，到 0 后就说明抢光了。
2. 拆红包：拆红包时，首先会实时计算金额，一般是通过二倍均值法实现（即 0.01 到剩余平均值的 2 倍之间）。
3. 红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。
4. 红包记录更新后需要转账，为了提升效率，最终的转账操作为异步操作，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。







一般来说，抢红包分为 3 步：

### 红包分配算法

红包金额分配时，由于是随机分配，所以有两种实现方案：实时拆分和预先生成。

#### 实时拆分

实时拆分，指的是在**抢红包时实时计算**每个红包的金额，以实现红包的拆分过程。

这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从**正态分布**规律。



#### 预先生成

预先生成，指的是在红包**开抢之前**已经完成了红包的**金额拆分**，抢红包时只是依次取出拆分好的红包金额。

这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。



#### 二倍均值法

综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，采用**二倍均值法**来生成随机红包。

即每次用户的随机金额在 `0.01 ~ 剩余平均值*2` 之间，假设当前红包剩余金额为 10 元，剩余个数为 5。

`10/5 = 2`，则当前用户可以抢到的红包金额为：`0.01 ~ 4` 元之间。



#### 算法优化

用二倍均值法生成的随机红包虽然接近平均值，但之前我在某论坛上看到过类似的说法：微信红包金额的随机性和领取的位置有关系。

于是，我耗费巨资在微信群发了很多个红包，得出了这样一个结论：如果发出的 `红包总额 = 红包数*0.01 + 0.01`，比如：发了 4 个红包，总额为 0.05，则最后一个人领取的红包金额一定是 `0.02`。

![img](imgs/e8fc3c93-2bfc-4b91-b214-8b7b61c2796b.jpg)

无一例外：

![img](imgs/9b24bfa6-3c2d-47a6-865f-b86de23b567d.jpg)

所以，红包金额算法大概率不是随机分配，而是在派发红包之前已经做了处理。比如在红包金额生成前，先新增一个不存在的红包，对每个红包的随机值基础上加上 0.01，以此来保证每个红包的最小值



算法逻辑用 Go 语言实现如下：

``` go
import "math/rand"

type RedPack struct {
    SurplusAmount float64 // 剩余金额
    SurplusTotal int // 红包剩余个数
}

func getRandomRedPack(rp RedPack) float64 {
    if rp.SurplusTotal == 1 {
        rp.SurplusTotal -= 1
        return rp.SurplusAmount
    }
    
    avgAmount := rp.SurplusAmount/float64(rp.SurplusTotal)
    rand.NewSource(time.Now().UnixNano()) // 生成随机数种子
    
    return rand.Float64()*(avgAmount*2-0.01) + 0.01
}
```





**核心组件：**

1. **红包生成器：** 这个组件用于创建红包，生成随机金额分配，并生成唯一的红包标识。
2. **红包发放服务：** 负责将红包发送到指定的微信群，确保公平的分配和避免重复领取。
3. **红包领取服务：** 处理用户领取红包的请求，包括验证用户资格，分配金额，记录领取历史等。
4. **红包状态管理：** 跟踪红包的状态，确保红包在合适的时间内被领取完毕。
5. **用户账户管理：** 维护用户的账户余额，包括红包领取和发送时的金额变动。

**数据库表设计：**

1. **User表：** 存储用户信息，包括用户ID、用户名、账户余额等。
2. **Group表：** 记录微信群的信息，如群ID、群名称等。
3. **RedPacket表：** 用于存储红包信息，包括红包ID、发送者ID、红包金额等。
4. **RedPacketRecord表：** 记录红包领取的历史，包括领取者ID、领取金额、领取时间等。



**详细设计方案：**

1. 使用高可用的分布式数据库来存储用户、群组和红包信息。
2. 利用消息队列，如RabbitMQ或Kafka，来处理用户的领取请求，确保高并发情况下的请求排队和处理。
3. 实现红包生成器，使用随机算法生成红包金额分配，确保红包公平性。
4. 设计后台服务的负载均衡策略，确保各个服务组件的平稳运行。
5. 实时更新红包状态，以保持用户对红包的可见性。

微信的群内抢红包功能背后蕴藏着复杂的技术和精心设计的系统，通过这些核心组件、数据库表和详细的交互流程，让用户能够轻松参与并享受抢红包的乐趣。这个功能的成功实现是技术与创意的完美融合，为微信群的互动增添了趣味和活力。



### 总结

微信建群功能的系统设计不仅仅是一个技术壮丽的展示，更是数字社交的魔法之一。通过高并发、高性能的设计，以及对海量数据的处理，微信创造了一个能让人们联系、分享和互动的数字社交魔法空间。

如果你曾好奇这些社交应用是如何工作的，希望这篇文章帮助你更好地理解了微信建群功能的背后系统设计。数字社交的世界无处不在，而它的魔法则是深思熟虑的系统设计。

希望你享受了这次探索之旅，下次再见！ 🚀