## 1. 引言

大家好，我是小❤。

当我那天拿着手机，正在和朋友们的微信群里畅聊着八卦新闻和即将到来的周末计划时，忽然一条带着喜意的消息扑面而来，消息正中间写着八个大字：**恭喜发财，大吉大利**。

![img](imgs/80e84348-4be2-43ce-b560-5c2a7f28f486.jpg)

抢红包！！相信大部分人对此都不陌生，那微信的这个群聊系统是如何设计的，让我们可以方便地聊天、分享图片和表情，还有那个神奇的红包功能呢？

这个问题一直困扰着，于是我决定深入了解一下，看看微信的群聊系统背后的设计是怎样的。



### 微信群聊系统设计

微信作为 10 亿用户级别的全民 App，想必大家都用过，微信建群功能是微信里面核心的一个能力，它可以将数百个好友或陌生人放进一个群空间。

![img](imgs/40678333-442e-422f-891b-185dc1260532.jpg)

或许你已经在微信上体验过很多次群组聊天，但你是否好奇过这个背后的系统是如何设计的呢？

今天我们就来探讨一下。



参考资料：

阿里云（业务流程）：https://developer.aliyun.com/article/936484

知乎（主要是拆红包算法设计）：https://zhuanlan.zhihu.com/p/240309293

系列文章：http://www.52im.net/thread-2202-1-1.html

产品经理：https://www.woshipm.com/pd/232838.html#toc-6

掘金（关注交互和锁）：https://juejin.cn/post/6925947709517987848



## 2. 系统需求

### 2.1 系统特点与功能需求



## 6. 抢红包

抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要**保证每个用户的红包金额不小于 0.01 元**。

![img](imgs/659eab44-e2d3-497d-88fa-1355180b2128.jpg)

抢红包的详细交互流程如下：

1. 用户接收到抢红包通知，点击通知打开群聊页面
2. 用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包
4. 若用户资格验证通过，后台服务分配红包金额并存储领取记录
5. 用户在微信群中看到领取金额，红包状态更新为“已领取”
5. 异步调用支付接口，将红包金额更新到钱包里

抢红包功能需要关注抢红包的数据库设计，抢红包实时性和红包分配算法。



### 6.1 数据库设计

红包表 `redpack` 的字段如下：

* **id：** 主键，红包ID
* **totalAmount：** 总金额
* **surplusAmount：** 剩余金额
* **total：** 红包总数
* **surplusTotal：** 剩余红包总数
* **userId：** 发红包的用户ID

该表用来记录用户发了多少红包，以及需要维护的剩余金额。



红包记录表 `redpack_record` 如下：

* **id：** 主键，记录ID
* **redpackId：** 红包ID，外键
* **userId：** 用户ID
* **amount：** 抢到的金额

记录表用来存放用户具体抢到的红包信息，也是红包表的副表。



### 6.2 实时性

#### 1、发红包

1. 用户设置红包的总金额和个数后，在红包表中增加一条数据，开始发红包
2. 为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，`存储红包 ID 和总人数 n`
3. 抢红包消息推送给所有群成员



#### 2、抢红包

从 2015 年起，微信红包的抢红包和拆红包就分离了，用户点击抢红包后需要进行两次操作。这也是为什么明明有时候抢到了红包，点开后却发现**该红包已经被领取完了**。

![img](imgs/手慢无.jpg)

抢红包的交互步骤如下：

1. 抢红包：抢操作在 `Redis` 缓存层完成，**通过原子递减的操作来更新红包个数**，到 0 后就说明抢光了。
2. 拆红包：拆红包时，首先会实时计算金额，一般是通过**二倍均值法**实现（即 0.01 到剩余平均值的 2 倍之间）。
3. 红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。
4. 转账：为了提升效率，最终的**转账为异步操作**，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。



### 6.3 红包分配算法

红包金额分配时，由于是随机分配，所以有两种实现方案：实时拆分和预先生成。

#### 1、实时拆分

实时拆分，指的是在**抢红包时实时计算**每个红包的金额，以实现红包的拆分过程。

这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从**正态分布**规律。



#### 2、预先生成

预先生成，指的是在红包**开抢之前**已经完成了红包的**金额拆分**，抢红包时只是依次取出拆分好的红包金额。

这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。



#### 3、二倍均值法

综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，用**二倍均值法**来生成随机红包，只满足随机即可，不需要正态分布。

> 故可能出现很大的红包差额，但这更刺激不是吗:dog:

使用二倍均值法生成的随机数，每次随机金额会在 `0.01 ~ 剩余平均值*2` 之间。

假设当前红包剩余金额为 10 元，剩余个数为 5，`10/5 = 2`，则当前用户可以抢到的红包金额为：`0.01 ~ 4` 元之间。



#### 4、算法优化

用二倍均值法生成的随机红包虽然接近平均值，但之前我在某论坛上看到过类似的说法：**微信红包金额的随机性和领取的时机有关系，尤其是金额不高的情况下**。

于是，小❤耗费巨资在微信群发了多个红包，得出了这样一个结论：如果发出的 `红包总额 = 红包数*0.01 + 0.01`，比如：发了 4 个红包，总额为 0.05，则最后一个人领取的红包金额一定是 `0.02`。

![img](imgs/e8fc3c93-2bfc-4b91-b214-8b7b61c2796b.jpg)

无一例外：

![image-20231031212737389](imgs/image-20231031212737389.png)

所以，红包金额算法大概率不是随机分配，而是在派发红包之前已经做了处理。比如在红包金额生成前，先生成一个不存在的红包，这个红包的总额为 `0.01 * 红包总数`。

而在红包金额分配的时候，会对每个红包的随机值基础上加上 `0.01`，以此来保证每个红包的最小值不为 0。

所以，假设用户发了总额为 0.04 的个数为 3 的红包时，需要先提取 `3*0.01` 到 "第四个" 不存在的红包里面，于是第一个人抢到的红包随机值是 `0 ~ (0.04-3*0.01)/3`。

由于担心红包超额，所以除数的商是向下取二位小数，`0 ~ (0.04-3*0.01)/3 ==> (0 ~ 0) = 0`，再加上之前提取的保底值 `0.01`，于是前两个抢到的红包金额都是 `0.01`。最后一个红包的金额为红包余额，即 `0.02`。



算法逻辑用 Go 语言实现如下：

``` go
import (
    "fmt"
    "math"
    "math/rand"
    "strconv"
)

type RedPack struct {
    SurplusAmount float64 // 剩余金额
    SurplusTotal int // 红包剩余个数
}

// 取两位小数
func remainTwoDecimal(num float64) float64 {
	numStr := strconv.FormatFloat(num, 'f', 2, 64)
	num, _ = strconv.ParseFloat(numStr, 64)
	return num
}

// 获取随机金额的红包
func getRandomRedPack(rp *RedPack) float64 {
	if rp.SurplusTotal <= 0 {
                // 该红包已经被抢完了
		return 0
	}

	if rp.SurplusTotal == 1 {
		return remainTwoDecimal(rp.SurplusAmount + 0.01)
	}

        // 向下取整
	avgAmount := math.Floor(100*(rp.SurplusAmount/float64(rp.SurplusTotal))) / float64(100)
	avgAmount = remainTwoDecimal(avgAmount)

        // 生成随机数种子
	rand.NewSource(time.Now().UnixNano())

	var max float64
	if avgAmount > 0 {
		max = 2*avgAmount - 0.01
	} else {
		max = 0
	}
	money := remainTwoDecimal(rand.Float64()*(max) + 0.01)

	rp.SurplusTotal -= 1
	rp.SurplusAmount = remainTwoDecimal(rp.SurplusAmount + 0.01 - money)

	return money
}

func main() {
	rp := &RedPack{
		SurplusAmount: 0.06,
		SurplusTotal:  5,
	}
	rp.SurplusAmount -= 0.01 * float64(rp.SurplusTotal)
	total := rp.SurplusTotal
	for i := 0; i < total; i++ {
		fmt.Println(getRandomRedPack(rp))
	}
}
```

打印结果：

> 0.01、0.01、0.01、0.01、0.02

符合预期！



## 7. 总结

微信群聊及抢红包等功能背后蕴藏着复杂的交互技术和精心设计的产品体验，通过这些核心组件、数据库表和详细的交互流程，让用户能够轻松参与并享受群聊系统带来的便利。

并且，添加了这些充满趣味的功能，也是微信用户众多的原因之一吧！

微信建群功能的系统设计不仅仅是一个技术壮丽的展示，更是数字社交的魔法之一。



由于篇幅有限，文章对系统高并发、高性能的设计，以及对海量数据的处理浅尝辄止，后续可能会出一个专栏来详细介绍，感兴趣的朋友可以关注一下。



如果你曾好奇这些社交应用是如何工作的，希望这篇文章帮助你更好地理解了微信建群功能的背后系统设计。

如果觉得文章有所启发或收获，不妨点赞、分享，让更多人了解这个有趣的领域吧！

我是小❤，我们下期再见！